-- Load Vape UI Library
local lib = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/UI-Libs/main/Vape.txt"))()

-- Create UI Window
local win = lib:Window("Football Game Helper", Color3.fromRGB(44, 120, 224), Enum.KeyCode.RightControl)

-- Create "Jump Helper" Tab
local jumpHelperTab = win:Tab("Jump Helper")

-- Variables
local OptimalJumpEnabled = false
local predictionColor = Color3.fromRGB(255, 255, 255)
local circle -- The visual indicator for the optimal jump location

-- Toggle for Optimal Jump Location
jumpHelperTab:Toggle("Enable Optimal Jump Location", false, function(t)
    OptimalJumpEnabled = t
    if not OptimalJumpEnabled then
        if circle then
            circle:Destroy()
        end
    end
end)

-- Color Picker for Optimal Jump Location
jumpHelperTab:Colorpicker("Jump Location Color", Color3.fromRGB(255, 255, 255), function(c)
    predictionColor = c
    if circle then
        circle.BrickColor = BrickColor.new(predictionColor)
    end
end)

-- Function to Simulate Ball Trajectory
local function beamProjectile(g, v0, x0, t1)
    local c = 0.5 * 0.5 * 0.5
    local p3 = 0.5 * g * t1 * t1 + v0 * t1 + x0
    local p2 = p3 - (g * t1 * t1 + v0 * t1) / 3
    local p1 = (c * g * t1 * t1 + 0.5 * v0 * t1 + x0 - c * (x0 + p3)) / (3 * c) - p2

    return p3
end

-- Function to Show Optimal Jump Location
local function showOptimalJumpLocation()
    if not OptimalJumpEnabled then return end

    -- Remove existing visual indicator
    if circle then
        circle:Destroy()
    end

    -- Create a Part for visualization
    circle = Instance.new("Part")
    circle.Size = Vector3.new(5, 1, 5) -- Adjust size as needed
    circle.Anchored = true
    circle.CanCollide = false
    circle.Transparency = 0.5
    circle.BrickColor = BrickColor.new(predictionColor)
    circle.Material = Enum.Material.SmoothPlastic
    circle.Parent = Workspace

    -- Connect to event when ball is added
    workspace.ChildAdded:Connect(function(b)
        if b.Name == "Football" and b:IsA("BasePart") then
            task.wait()
            local velocity = b.Velocity
            local position = b.Position

            -- Calculate the optimal jump location
            local predictedEndPosition = beamProjectile(Vector3.new(0, -28, 0), velocity, position, 10)
            local optimalLocation = Vector3.new(predictedEndPosition.X, Workspace.CurrentCamera.CFrame.Position.Y, predictedEndPosition.Z)

            -- Update the Part's position
            circle.Position = optimalLocation

            -- Continuously update position while the ball is moving
            local updateConnection
            updateConnection = RunService.Heartbeat:Connect(function()
                if b.Velocity.Magnitude > 0.1 then
                    predictedEndPosition = beamProjectile(Vector3.new(0, -28, 0), b.Velocity, b.Position, 10)
                    optimalLocation = Vector3.new(predictedEndPosition.X, Workspace.CurrentCamera.CFrame.Position.Y, predictedEndPosition.Z)
                    circle.Position = optimalLocation
                else
                    circle:Destroy()
                    updateConnection:Disconnect()
                end
            end)

            -- Remove the Part when the ball is caught or disappears
            task.spawn(function()
                repeat task.wait() until b.Parent ~= workspace
                circle:Destroy()
                updateConnection:Disconnect()
            end)
        end
    end)
end

-- Function to Start the Optimal Jump Location Feature
local function startJumpHelper()
    if OptimalJumpEnabled then
        showOptimalJumpLocation()
    end
end

-- Run the Jump Helper Function Continuously
RunService.Heartbeat:Connect(startJumpHelper)
